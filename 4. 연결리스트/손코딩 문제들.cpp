/*
문제
1. 원형 연결 리스트 내의 임의의 노드 하나가 주어졌을 때 해당 List의 길이를 효율적으로 구하는 방법?

답변 
1. 임의의 노드에서 양방향으로 노드를 하나씩 count하다가, 둘이 만나는 지점에서 종료하고 노드 개수를 합산한다.

정답
1. 동일한 노드가 나올 때 까지 계속 다음 노드로 가면 도미, 공간복잡도 O(1), 시간 복잡도 O(N)


문제
2. 중간에 만나는 두 연결 리스트의 시작점들이 주어졌을 때 만다는 지점을 구하는 방법?

답변
1. 두 연결리스트의 동일한 지점을 가르키는 곳이 나올 때까지 반복, 시간복잡도 O(N^2), 공간복잡도 O(N)

정답
1. 두 시작점에 대해 끝까지 진행시켜 각각의 길이를 구함. 
그 후 다시 두 시작점으로 돌아와서 더 긴 쪽을 둘의 차이만큼 먼저 이동하고,
두 시작점이 만날 때 까지 두 시작점을 동시에 한 칸씩 전진시키면 됨. 공간복잡도 O(1), 시간복잡도 O(A+B)


문제
3. 연결 리스트에서 사이클이 있는지 판단하라

정답
1. floyd's cycle-finding algorithm, 공간복잡도 O(1), 시간복잡도 O(N)
 - 한 칸씩 가는 커서와 두 칸씩 가는 커서를 동일한 시작점에서 출발시키면 사이클이 있는 경우 반드시 만나게 된다.

반대로 만약 사이클이 없으면 두 커서가 만나지 못하고 연결 리스트의 끝에 도달하지 못하게 된다.

이 방식으로 사용하면 거치는 모든 노드를 저장할 필요 없이 공간 복잡도 O(1)에 사이클의 존재 여부를 확인할 수 있다.
*/
